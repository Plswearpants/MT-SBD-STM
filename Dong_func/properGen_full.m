function [Y, A0_noiseless, X0, params] = properGen_full(varargin)
    % This function generates a 3D synthetic STM observation using blocks of consecutive
    % slices from selected LDoS simulation data. Each block starts from a user-selected
    % slice and extends for num_slices using periodic boundary conditions. Each block
    % has its own activation map, and the final observation is generated by summing
    % the convolutions of each blocks kernels with its activation map.
    %
    % Required Inputs:
    %   SNR: Signal-to-noise ratio
    %   N_obs: Size of observation lattice (N_obs x N_obs)
    %   observation_resolution: Resolution factor (pixels per lattice site)
    %   defect_density: Surface defect density (between 0 and 1)
    %
    % Optional Inputs:
    %   LDoS_path: Path to LDoS simulation data
    %   num_slices: Number of consecutive slices per block (default: 3)
    %   vis: Boolean flag to show intermediate visualization steps (default: false)
    %
    % Outputs:
    %   Y: Final observation (pN_obs x pN_obs x num_slices pixels)
    %   A0: Cell array of resized single defect patterns (num_kernels x num_slices)
    %   X0: Activation maps for each kernel (num_kernels x pN_obs x pN_obs)
    %   params: Structure containing all parameters used
    %
    % Example:
    %   % Basic usage with default parameters
    %   SNR = 2;              % Signal-to-noise ratio
    %   N_obs = 50;           % Observation lattice size (50x50)
    %   observation_resolution = 3;  % Resolution: 3 pixels per lattice site
    %   defect_density = 0.001;      % 0.1% defect density
    %   
    %   [Y, A0, X0, params] = properGen_full(SNR, N_obs, observation_resolution, defect_density);
    %   
    %   % Advanced usage with custom parameters
    %   [Y, A0, X0, params] = properGen_full(SNR, N_obs, observation_resolution, defect_density, ...
    %       'LDoS_path', 'path/to/custom/LDoS_data.mat', ...
    %       'num_slices', 5);
    %
    %   % The function will:
    %   % 1. Load LDoS data from the specified path
    %   % 2. Display data for slice selection
    %   % 3. Allow user to select starting slices for each block
    %   % 4. For each selected slice:
    %   %    - Generate a unique activation map
    %   %    - Create a block of consecutive slices using periodic boundary conditions
    %   %    - Process each slice in the block to create kernels
    %   % 5. Generate final observation by summing convolutions of each blocks
    %   %    kernels with its activation map
    %   % 6. Add noise based on specified SNR
    %   % 7. Return the observation, kernels, activation maps, and parameters
    %
    %   % Accessing the results:
    %   % Y(:,:,1) - First slice of the final observation
    %   % A0{1,1} - First kernel of first block
    %   % squeeze(X0(1,:,:)) - Activation map for first block
    %   % params.selected_indices - Indices of selected starting slices
    %   % params.cutoff_M - Cutoff values for each kernel
    %   % params.kernel_sizes - Target sizes for each kernel
    %
    %   % Visualization:
    %   % The function automatically displays:
    %   % - Activation maps for each block
    %   % - Final observation slices
    %   % - 3D view of the entire observation

    %% a. Initial Setup
    % Parse inputs
    p = inputParser;
    p.addRequired('SNR');
    p.addRequired('N_obs');
    p.addRequired('observation_resolution');
    p.addRequired('defect_density');
    p.addParameter('LDoS_path', 'example_data/LDoS_sim.mat');
    p.addParameter('num_slices', 3);
    p.addParameter('vis', false);
    p.parse(varargin{:});
    
    % Extract parameters
    SNR = p.Results.SNR;
    N_obs = p.Results.N_obs;
    p_scale = p.Results.observation_resolution;
    rho_d = p.Results.defect_density;
    LDoS_path = p.Results.LDoS_path;
    num_slices = p.Results.num_slices;
    vis = p.Results.vis;
    
    % Validate parameters
    if SNR <= 0
        error('SNR must be positive');
    end
    if N_obs <= 0 || ~(floor(N_obs) == N_obs)
        error('N_obs must be a positive integer');
    end
    if p_scale <= 0 || ~(floor(p_scale) == p_scale)
        error('observation_resolution must be a positive integer');
    end
    if rho_d <= 0 || rho_d >= 1
        error('defect_density must be between 0 and 1');
    end
    if num_slices <= 0 || ~(floor(num_slices) == num_slices)
        error('num_slices must be a positive integer');
    end
    
    % Load LDoS simulation data
    try
        loaded_data = load(LDoS_path);
        % Load N_single from file
        if isfield(loaded_data, 'N')
            N_single = loaded_data.N;
        else
            error('N not found in the loaded file. This parameter is required.');
        end
        
        % Load rho_single
        if isfield(loaded_data, 'LDoS_sim')
            rho_single = loaded_data.LDoS_sim;
        else
            potential_fields = find(structfun(@(x) ndims(x) >= 2, loaded_data));
            field_names = fieldnames(loaded_data);
            
            if length(potential_fields) == 1
                rho_single = loaded_data.(field_names{potential_fields});
            elseif length(potential_fields) > 1
                [idx, ok] = listdlg('ListString', field_names(potential_fields), ...
                                  'SelectionMode', 'single', ...
                                  'PromptString', 'Select the QPI data field:');
                if ~ok
                    error('No field selected');
                end
                rho_single = loaded_data.(field_names{potential_fields(idx)});
            else
                error('No suitable data field found in the file');
            end
        end
    catch ME
        error('Error loading file: %s', ME.message);
    end
    
    % Validate LDoS data
    if isempty(rho_single) || ~isnumeric(rho_single) || ndims(rho_single) < 2
        error('Invalid LDoS data format');
    end
    if ndims(rho_single) == 2
        rho_single = rho_single(:,:,1);
    end
    
    % Display full dataset for user review
    disp('Displaying full dataset. Use slider to review all slices.');
    disp('Close the display window when ready to proceed with slice selection.');
    figure;
    d3gridDisplay(rho_single, 'dynamic');
    
    % Handle slice selection
    total_slices = size(rho_single, 3);
    fprintf('\nTotal available slices: %d\n', total_slices);
    
    % Get slice selection from command line
    while true
        input_str = input('Enter slice numbers separated by spaces (e.g., "2 14"): ', 's');
        selected_indices = str2num(input_str); %#ok<ST2NM>
        
        % Validate input
        if isempty(selected_indices)
            fprintf('Invalid input. Please enter numbers separated by spaces.\n');
            continue;
        end
        
        if any(selected_indices < 1) || any(selected_indices > total_slices)
            fprintf('Invalid slice numbers. Must be between 1 and %d.\n', total_slices);
            continue;
        end
        
        break;
    end
    
    % Sort indices and remove duplicates
    selected_indices = unique(sort(selected_indices));
    num_kernels = length(selected_indices);
    fprintf('Selected starting slices: %s\n', num2str(selected_indices));
    
    % Create blocks of consecutive slices with periodic boundary conditions
    A0_noiseless = cell(num_slices,num_kernels);
    A0 = cell(num_slices,num_kernels);
    kernel_sizes = zeros(num_slices,num_kernels,2);
    X0 = zeros(N_obs*p_scale, N_obs*p_scale, num_kernels);
    rho_single_resized = cell(1, size(rho_single,3));
    cutoff_M = zeros(1, size(rho_single,3));
    target_size = zeros(size(rho_single,3),2);
    
    % created cutoffed kernels from rho_single and SNR
    for k = 1:size(rho_single,3)
        % Find cutoff M for this slice
        [M, M_pixels,~] = find_cutoff_noise_intersection(rho_single(:,:,k), SNR, N_single, false);
        cutoff_M(k) = M;
        
        % Get center and crop rho_single
        [ny, nx] = size(rho_single(:,:,k));
        center = ceil([ny, nx]/2);
        pixels_per_lattice = nx/N_single;
        
        % Crop the pattern
        range_y = max(1, center(1)-M_pixels):min(ny, center(1)+M_pixels);
        range_x = max(1, center(2)-M_pixels):min(nx, center(2)+M_pixels);
        rho_single_cutoff = rho_single(range_y, range_x, k);
        
        % Resize cutoff pattern to match observation scale
        target_size(k,:) = 2*floor(M*p_scale) + 1;  % Ensure odd dimensions
        rho_single_resized{k} = imresize(rho_single_cutoff, target_size(k,:));

        % Visualize intermediate steps if requested
        if vis
            figure('Name', sprintf('Step 1: Single Defect Processing - Slice %d', k));
            subplot(1,3,1);
            imagesc(rho_single(:,:,k));
            title('Original Single Defect Pattern');
            colorbar;
            axis square;
            
            subplot(1,3,2);
            imagesc(rho_single_cutoff);
            title(sprintf('Cropped Pattern (M=%d)', M));
            colorbar;
            axis square;
            
            subplot(1,3,3);
            imagesc(rho_single_resized{k});
            title(sprintf('Resized Pattern (%dx%d)', target_size(k,1), target_size(k,2)));
            colorbar;
            axis square;
        end
    end

    for b = 1:num_kernels
        % get the kernel size
        start_idx = selected_indices(b);
        block_indices = start_idx:start_idx+num_slices-1;
        
        % Generate Activation Map for each kernel 
        target_defects = round(N_obs * N_obs * rho_d);  % Expected number of defects
        tolerance = 0.1;  % 10% tolerance
        min_defects = max(round(target_defects * (1-tolerance)), 1);
        max_defects = round(target_defects * (1+tolerance));

        X_good = false;
        while ~X_good
            X = double(rand(N_obs, N_obs) <= rho_d);
            num_defects = sum(X(:));
            X_good = (num_defects >= min_defects) && (num_defects <= max_defects);
        end
        
        % Upsample X to match observation resolution
        X0(:,:,b) = upsample_with_zero_blocks(X, p_scale);
        
        % Visualize activation map generation if requested
        if vis
            figure('Name', sprintf('Step 2: Activation Map Generation - Block %d', b));
            subplot(1,2,1);
            imagesc(X);
            title(sprintf('Original Activation Map (N=%d)', N_obs));
            colorbar;
            axis square;
            
            subplot(1,2,2);
            imagesc(X0(:,:,b));
            title(sprintf('Upsampled Map (pN=%d)', N_obs*p_scale));
            colorbar;
            axis square;
        end
        
        % Handle periodic boundary conditions
        block_indices = mod(block_indices-1, total_slices) + 1;
            
        % Extract the block - use loop to assign each element individually
        for s = 1:num_slices
            A0_noiseless{s,b} = rho_single_resized{block_indices(s)};
            kernel_sizes(s,b,:) = size(A0_noiseless{s,b});
        end
    end
    
    % create Y from A0 and X0 by convolving A0{s,:} with X0(:,:,s)
    Y_clean = zeros(N_obs*p_scale, N_obs*p_scale, num_slices);
    for s = 1:num_slices
        for b = 1:num_kernels
            Y_clean(:,:,s) = Y_clean(:,:,s) + convfft2(A0_noiseless{s,b}, squeeze(X0(:,:,b)));
            
            % Visualize convolution steps if requested
            if vis
                figure('Name', sprintf('Step 3: Convolution - Slice %d, Block %d', s, b));
                subplot(2,2,1);
                imagesc(A0_noiseless{s,b});
                title('Kernel');
                colorbar;
                axis square;
                
                subplot(2,2,2);
                imagesc(squeeze(X0(:,:,b)));
                title('Activation Map');
                colorbar;
                axis square;
                
                subplot(2,2,3);
                imagesc(convfft2(A0_noiseless{s,b}, squeeze(X0(:,:,b))));
                title('Individual Convolution');
                colorbar;
                axis square;
                
                subplot(2,2,4);
                imagesc(Y_clean(:,:,s));
                title('Cumulative Result');
                colorbar;
                axis square;
            end
        end
    end
    
    % Add noise based on SNR - layer-wise (slice-wise)
    Y = zeros(size(Y_clean));
    eta_slices = zeros(1, num_slices);
    eta_norm = zeros(1, num_slices);
    
    for s = 1:num_slices
        % Calculate mean variance of kernels for this slice
        kernel_variances = zeros(1, num_kernels);
        for b = 1:num_kernels
            kernel_variances(b) = var(A0_noiseless{s,b}, [], 'all');
        end
        mean_kernel_variance = mean(kernel_variances);
        
        % Calculate noise variance based on kernel variance
        eta_slices(s) = mean_kernel_variance / SNR;
        
        % Add noise to this slice
        Y(:,:,s) = (Y_clean(:,:,s) + sqrt(eta_slices(s)) * randn(size(Y_clean(:,:,s))));
        Y_slice_norm = norm(Y(:,:,s),'fro');
        std_norm(s) = sqrt(eta_slices(s))/ Y_slice_norm;
    end
    
    Y = proj2oblique(Y);
    
    % Visualize noise addition if requested
    if vis
        figure('Name', 'Step 4: Noise Addition');
        subplot(1,2,1);
        imagesc(Y_clean(:,:,1));
        title('Clean Signal');
        colorbar;
        axis square;
        
        subplot(1,2,2);
        imagesc(Y(:,:,1));
        title(sprintf('Signal with Noise (SNR=%.1f)', SNR));
        colorbar;
        axis square;
    end
    
    % Add noise to each kernel
    for b = 1:num_kernels
        for s = 1:num_slices
            A0{s,b} = proj2oblique(A0_noiseless{s,b} + sqrt(eta_slices(s)) * randn(size(A0_noiseless{s,b})));
        end
    end

    % Package parameters
    params = struct();
    params.N_single = N_single;
    params.N_obs = N_obs;
    params.observation_resolution = p_scale;
    params.defect_density = rho_d;
    params.SNR = SNR;
    params.num_kernels = num_kernels;
    params.num_slices = num_slices;
    params.selected_indices = selected_indices;
    params.cutoff_M = cutoff_M;
    params.kernel_sizes = kernel_sizes;
    params.A0 = A0;
    params.X0 = X0;
    params.eta_slices = eta_slices;
    params.std_norm = std_norm;

    % Display 3D view
    figure('Name', '3D Observation');
    d3gridDisplay(Y, 'dynamic');
    title('3D View of Generated Observation');
end
   